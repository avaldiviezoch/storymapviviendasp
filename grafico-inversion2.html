<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Devengado Acumulado VS Monto de Inversión</title>
<style>
  :root{ --ink:#0b2532; --muted:#64748b; --grid:#e5e7eb; }
  html,body{height:100%;margin:0;background:#fff;color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial}
  .stage{height:100vh;width:100vw;display:grid;grid-template-rows:auto auto 1fr;
    gap:10px;padding:clamp(8px,2vw,20px); box-sizing:border-box}
  h1{margin:0;text-align:center;font-weight:900;letter-spacing:.3px;
     font-size:clamp(20px,3vw,42px)}
  .legendBar{display:flex;justify-content:center;align-items:center;gap:14px;flex-wrap:wrap;min-height:28px}
  .leg-btn{display:inline-flex;align-items:center;gap:8px;padding:6px 12px;border:1px solid #e5e7eb;border-radius:999px;cursor:pointer;background:#fff;font-weight:700;font-size:13px}
  .leg-btn[aria-pressed="false"]{opacity:.35;background:#f8fafc}
  .sw{width:12px;height:12px;border-radius:50%}
  .chartWrap{position:relative;overflow:hidden;border-radius:14px}
  canvas{display:block;width:100%;height:100%}
  .empty{display:grid;place-items:center;height:100%;color:#64748b;font-size:clamp(13px,1.6vw,16px);padding:12px;text-align:center}

  /* Tooltip */
  .tip{
    position:absolute; pointer-events:none; color:#0b2532;
    background:#ffffff; border:1px solid #e5e7eb;
    box-shadow:0 10px 24px rgba(2,6,23,.12), 0 2px 6px rgba(2,6,23,.08);
    border-radius:10px; padding:8px 10px; font-size:11px; line-height:1.25;
    opacity:0; transition:opacity .12s ease;
    max-width:min(360px,68vw); z-index:1000;
  }
  .tip .chip{
    display:inline-flex; align-items:center; gap:6px;
    font-weight:800; padding:3px 8px; border-radius:999px;
    background:#f8fafc; border:1px solid #e5e7eb; font-size:10.5px;
    letter-spacing:.02em;
  }
  .tip .dot{width:9px;height:9px;border-radius:50%;display:inline-block}
  .tip .grid{ margin-top:6px; display:grid; grid-template-columns:auto 1fr; gap:4px 10px; }
  .tip .k{color:#64748b}
  .tip .v{font-weight:700; text-align:right}
  .tip .hr{margin:6px 0; height:1px; background:#eef2f7; grid-column:1/-1}
  .tip .long{grid-column:1/-1; text-align:left; font-weight:600}

  /* Zoom */
  .zoom-controls{
    position:absolute; right:20px; top:20px; display:flex; flex-direction:column; gap:8px;
    z-index:10;
  }
  .zoom-btn{
    width:36px; height:36px; border-radius:8px; border:1px solid #e5e7eb;
    background:#fff; cursor:pointer; display:grid; place-items:center;
    font-size:18px; font-weight:bold; color:#374151;
    box-shadow:0 2px 8px rgba(0,0,0,0.1); transition:all 0.2s;
  }
  .zoom-btn:hover{ background:#f8fafc; border-color:#d1d5db; }
  .zoom-btn:active{ background:#e5e7eb; }
</style>
</head>
<body>
  <div class="stage">
    <h1>Devengado Acumulado VS Monto de Inversión</h1>
    <div class="legendBar" id="legendBar" role="toolbar" aria-label="Filtrar por Nivel de Avance"></div>

    <div class="chartWrap" id="wrap" aria-live="polite">
      <canvas id="chart"></canvas>
      <div id="empty" class="empty" style="display:none">Sin datos que cumplan los filtros.</div>
      <div id="tip" class="tip" role="status"></div>
      <div class="zoom-controls">
        <button class="zoom-btn" id="zoomIn" title="Acercar">+</button>
        <button class="zoom-btn" id="zoomOut" title="Alejar">−</button>
        <button class="zoom-btn" id="zoomReset" title="Restablecer zoom">↺</button>
      </div>
    </div>
  </div>

<script>
/* -------- Endpoints -------- */
const LYR13 = "https://pportalgis.vivienda.gob.pe/pfdserver/rest/services/OGEI/Mapa_Inversiones_MEF/FeatureServer/13/query";
const LYR1  = "https://pportalgis.vivienda.gob.pe/phtserver/rest/services/Hosted/story_monitoreo_inversiones/FeatureServer/1/query";

/* -------- Filtros -------- */
const WHERE_13 = "monto_pim > 0 AND producto_proyecto IS NOT NULL AND producto_proyecto <> 2193247";
const WHERE_1 = "etapa IN ('OBRA','OBRA (SALDO)') AND montoactualizadopip_decimal > 0 AND devengadoacumulado >= 0";

/* -------- Categorías -------- */
const CATS = [
  {key:"Bajo (0%–30%)",   short:"Bajo",  color:"#dc2626", match:p=> p<=30},
  {key:"Medio (30%–70%)", short:"Medio", color:"#f59e0b", match:p=> p>30 && p<70},
  {key:"Alto (70%–100%)", short:"Alto",  color:"#22c55e", match:p=> p>=70},
];

/* Utils */
function pct(dev, inv){ const d=+dev, m=+inv; return (!isFinite(d)||!isFinite(m)||m<=0)?0:(d/m)*100; }
function catFromPct(p){ for(const c of CATS){ if(c.match(p)) return c.short; } return "Bajo"; }
function fmtCompact(n){
  const v=Number(n)||0, a=Math.abs(v);
  if(a>=1e9) return (v/1e9).toFixed(1).replace(/\.0$/,'')+" B";
  if(a>=1e6) return (v/1e6).toFixed(1).replace(/\.0$/,'')+" M";
  if(a>=1e3) return (v/1e3).toFixed(1).replace(/\.0$/,'')+" k";
  return v.toLocaleString('es-PE');
}
function fmtPct(p){ return (Math.round(p*10)/10).toLocaleString('es-PE')+"%"; }

/* ArcGIS helpers */
async function fetchAllPOST(url, baseParams){
  const pageSize=2000; let offset=0, out=[];
  while(true){
    const body = new URLSearchParams({
      ...baseParams, returnGeometry:"false", f:"json",
      resultRecordCount: pageSize, resultOffset: offset
    }).toString();
    const res = await fetch(url, {
      method:"POST",
      headers:{ "Content-Type":"application/x-www-form-urlencoded;charset=UTF-8" },
      body, cache:"no-store"
    });
    if(!res.ok) throw new Error("HTTP "+res.status);
    const j = await res.json();
    if(j.error) throw new Error("ArcGIS: "+(j.error.message||"consulta inválida"));
    const feats = j.features ?? [];
    out.push(...feats.map(f=>f.attributes||{}));
    if(!j.exceededTransferLimit && feats.length<pageSize) break;
    offset += pageSize;
  }
  return out;
}

/* Carga */
async function loadData(){
  const rows13 = await fetchAllPOST(LYR13, { where: WHERE_13, outFields: "producto_proyecto" });
  const idSet = new Set(rows13.map(r=>r.producto_proyecto).filter(v=>v!=null));
  if(idSet.size===0) return [];
  const ids = Array.from(idSet);
  const chunkSize = 900;
  let rows1 = [];
  for(let i=0;i<ids.length;i+=chunkSize){
    const slice = ids.slice(i,i+chunkSize);
    const where = `${WHERE_1} AND icodunificado IN (${slice.join(",")})`;
    const part = await fetchAllPOST(LYR1, {
      where,
      outFields: "icodunificado,devengadoacumulado,montoactualizadopip_decimal,nombreproyecto,beneficiarios"
    });
    rows1.push(...part);
  }
  return rows1.map(r=>{
    const x = +r.devengadoacumulado||0;
    const y = +r.montoactualizadopip_decimal||0;
    const bens = +r.beneficiarios||0;
    const p = pct(x,y);
    return { x, y, bens, pct:p, nivel:catFromPct(p),
             icod: r.icodunificado ?? "", nombre: (r.nombreproyecto ?? "").toString().trim() };
  }).filter(d=>d.y>0);
}

/* Gráfico */
function makeChart(points){
  const wrap   = document.getElementById("wrap");
  const canvas = document.getElementById("chart");
  const ctx    = canvas.getContext("2d");
  const empty  = document.getElementById("empty");
  const tip    = document.getElementById("tip");
  const legend = document.getElementById("legendBar");

  if(!points.length){ empty.style.display="grid"; return; }
  empty.style.display="none";

  // Leyenda
  const visible = new Map(CATS.map(c=>[c.short,true]));
  legend.innerHTML="";
  CATS.forEach(c=>{
    const b=document.createElement("button");
    b.className="leg-btn"; b.type="button"; b.setAttribute("aria-pressed","true");
    b.innerHTML=`<span class="sw" style="background:${c.color}"></span>${c.key}`;
    b.onclick=()=>{ const cur=visible.get(c.short); visible.set(c.short,!cur); b.setAttribute("aria-pressed",String(!cur)); draw(); };
    legend.appendChild(b);
  });

  // Tamaño por beneficiarios
  const maxB = Math.max(1, ...points.map(p=>p.bens||0));
  const minR = 4, maxR = 22;
  const rScale = (b)=> {
    const t = Math.sqrt((b||0)/maxB);
    return minR + t * (maxR - minR);
  };

  // Estado
  let dims={}, scale={}, plot={}, HIT=[];
  let view = { minX:0, maxX:1, minY:0, maxY:1, dataMinX:0, dataMaxX:1, dataMinY:0, dataMaxY:1 };

  function computeDataExtents(){
    const act=points.filter(p=>visible.get(p.nivel));
    view.dataMaxX = Math.max(1, ...act.map(p=>p.x));
    view.dataMaxY = Math.max(1, ...act.map(p=>p.y));
    if(view.maxX===1 && view.maxY===1){
      view.minX=0; view.maxX=view.dataMaxX;
      view.minY=0; view.maxY=view.dataMaxY;
    }
  }

  function compute(){
    const dpr=Math.max(1,window.devicePixelRatio||1);
    const W=wrap.clientWidth, H=wrap.clientHeight;
    canvas.width=W*dpr; canvas.height=H*dpr; 
    canvas.style.width=W+"px"; canvas.style.height=H+"px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
    dims={W,H};

    const pad={t:40, r:24, b:64, l:86};
    plot = { x:pad.l, y:pad.t, w: W - pad.l - pad.r, h: H - pad.t - pad.b };
    scale={
      pad, plot,
      x: v => pad.l + plot.w * ((v - view.minX) / ((view.maxX - view.minX) || 1)),
      y: v => pad.t + plot.h * (1 - (v - view.minY) / ((view.maxY - view.minY) || 1)),
      invX: px => view.minX + (view.maxX - view.minX) * ((px - pad.l) / (plot.w || 1)),
      invY: py => view.minY + (view.maxY - view.minY) * (1 - (py - pad.t) / (plot.h || 1))
    };
  }

  function zoom(factor, centerX = null, centerY = null){
    if(centerX === null) centerX = (view.minX + view.maxX) / 2;
    if(centerY === null) centerY = (view.minY + view.maxY) / 2;
    const newWidth = (view.maxX - view.minX) * factor;
    const newHeight = (view.maxY - view.minY) * factor;
    view.minX = centerX - newWidth / 2;
    view.maxX = centerX + newWidth / 2;
    view.minY = centerY - newHeight / 2;
    view.maxY = centerY + newHeight / 2;
    clampView(); draw();
  }

  function pan(deltaX, deltaY){
    const spanX = view.maxX - view.minX;
    const spanY = view.maxY - view.minY;
    view.minX -= deltaX * spanX;
    view.maxX -= deltaX * spanX;
    view.minY += deltaY * spanY; // Y invertida
    view.maxY += deltaY * spanY;
    clampView(); draw();
  }

  function resetZoom(){
    view.minX=0; view.maxX=view.dataMaxX;
    view.minY=0; view.maxY=view.dataMaxY;
    draw();
  }

  function clampView(){
    const minSpanX = (view.dataMaxX - 0) / 1000;
    const minSpanY = (view.dataMaxY - 0) / 1000;
    if(view.maxX - view.minX < minSpanX){
      const cx=(view.minX+view.maxX)/2; view.minX=cx-minSpanX/2; view.maxX=cx+minSpanX/2;
    }
    if(view.maxY - view.minY < minSpanY){
      const cy=(view.minY+view.maxY)/2; view.minY=cy-minSpanY/2; view.maxY=cy+minSpanY/2;
    }
    view.minX = Math.max(0, view.minX);
    view.maxX = Math.min(view.dataMaxX, view.maxX);
    view.minY = Math.max(0, view.minY);
    view.maxY = Math.min(view.dataMaxY, view.maxY);
    if(view.minX >= view.maxX) view.maxX = view.minX + minSpanX;
    if(view.minY >= view.maxY) view.maxY = view.minY + minSpanY;
  }

  function drawAxes(){
    const {pad}=scale; const {W,H}=dims;
    ctx.clearRect(0,0,W,H);

    // Grilla + ticks Y
    ctx.textAlign="right"; ctx.textBaseline="middle"; ctx.font="12px system-ui"; ctx.fillStyle="#0b2532";
    const yTicks=5;
    for(let i=0;i<=yTicks;i++){
      const v = view.minY + (view.maxY - view.minY) * i / yTicks;
      const yy = scale.y(v);
      ctx.strokeStyle = i===0 ? "#e5e7eb" : "#f3f4f6";
      ctx.beginPath(); ctx.moveTo(pad.l, yy); ctx.lineTo(pad.l + scale.plot.w, yy); ctx.stroke();
      ctx.fillText(fmtCompact(v), pad.l - 8, yy);
    }

    // Grilla + ticks X
    ctx.textAlign="center"; ctx.textBaseline="top"; ctx.font="12px system-ui";
    const xTicks=5; const y0=H - pad.b;
    for(let i=0;i<=xTicks;i++){
      const v = view.minX + (view.maxX - view.minX) * i / xTicks;
      const xx = scale.x(v);
      ctx.strokeStyle="#e5e7eb";
      ctx.beginPath(); ctx.moveTo(xx, pad.t); ctx.lineTo(xx, y0); ctx.stroke();
      ctx.fillText(fmtCompact(v), xx, y0 + 10);
    }

    // Etiquetas
    ctx.save(); ctx.fillStyle="#0b2532"; ctx.font="600 13px system-ui";
    ctx.translate(28, H/2); ctx.rotate(-Math.PI/2); ctx.fillText("Monto de Inversión", 0, 0); ctx.restore();
    ctx.textAlign="center"; ctx.textBaseline="bottom";
    ctx.fillText("Devengado Acumulado", pad.l + scale.plot.w/2, H - 6);
  }

  function inPlot(px, py){
    return px >= plot.x && px <= plot.x + plot.w && py >= plot.y && py <= plot.y + plot.h;
  }

  function drawPoints(){
    HIT = [];
    // CLIP al rectángulo de trazado
    ctx.save();
    ctx.beginPath();
    ctx.rect(plot.x, plot.y, plot.w, plot.h);
    ctx.clip();

    CATS.forEach(c=>{
      if(!visible.get(c.short)) return;
      ctx.fillStyle = c.color;
      points.forEach(p=>{
        if(p.nivel !== c.short) return;
        const x=scale.x(p.x), y=scale.y(p.y), r=rScale(p.bens);
        if(!isFinite(x)||!isFinite(y)) return;
        // Dibujar (el clip evita que se salga)
        ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2); ctx.fill();
        // Para interacción, solo guardamos si el centro cae dentro del plano
        if(inPlot(x,y)){
          HIT.push({x, y, r: Math.max(r + 2, 8), data:p, color:c.color, key:c.key});
        }
      });
    });

    ctx.restore();
  }

  function draw(){ computeDataExtents(); compute(); drawAxes(); drawPoints(); }

  // Tooltip posicionado
  function positionTooltip(tipElement, mouseX, mouseY){
    const wrapRect = wrap.getBoundingClientRect();
    const tipRect = tipElement.getBoundingClientRect();
    const margin = 10;
    let left = mouseX + 12;
    let top  = mouseY - tipRect.height - 10;
    if (left + tipRect.width > wrapRect.width - margin) left = mouseX - tipRect.width - 12;
    if (left < margin) left = margin;
    if (top < margin) top = mouseY + 20;
    if (top + tipRect.height > wrapRect.height - margin) top = wrapRect.height - tipRect.height - margin;
    tipElement.style.left = left + "px";
    tipElement.style.top  = top  + "px";
  }

  /* Interacciones */
  function setupInteractions(){
    document.getElementById('zoomIn').addEventListener('click', ()=> zoom(0.7));
    document.getElementById('zoomOut').addEventListener('click', ()=> zoom(1.3));
    document.getElementById('zoomReset').addEventListener('click', resetZoom);

    // Wheel zoom solo dentro del plano
    canvas.addEventListener('wheel', (e)=>{
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      if(!inPlot(mx,my)) return; // ignorar fuera del plano
      const dataX = scale.invX(mx);
      const dataY = scale.invY(my);
      const factor = e.deltaY > 0 ? 1.2 : 1/1.2;
      zoom(factor, dataX, dataY);
    }, { passive:false });

    // Drag pan solo si el mousedown fue dentro del plano
    let isDragging=false, lastX=0, lastY=0;
    canvas.addEventListener('mousedown', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      if(!inPlot(mx,my)) return;
      isDragging=true; lastX=e.clientX; lastY=e.clientY;
      canvas.style.cursor='grabbing'; tip.style.opacity=0;
    });
    window.addEventListener('mousemove', (e)=>{
      if(!isDragging) return;
      const dx = (e.clientX - lastX) / (scale.plot.w || 1);
      const dy = (e.clientY - lastY) / (scale.plot.h || 1);
      pan(dx, dy);
      lastX=e.clientX; lastY=e.clientY;
    });
    window.addEventListener('mouseup', ()=>{
      isDragging=false; canvas.style.cursor='default';
    });

    // Doble clic para reset
    canvas.addEventListener('dblclick', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      if(inPlot(mx,my)) resetZoom();
    });

    // Tooltip dentro del plano
    function hitTest(mx,my){
      if(!inPlot(mx,my)) return null;
      for(let i=HIT.length-1;i>=0;i--){
        const h=HIT[i], dx=mx-h.x, dy=my-h.y;
        if(dx*dx + dy*dy <= h.r*h.r) return h;
      }
      return null;
    }

    function showTooltip(hit, mouseX, mouseY){
      const d = hit.data;
      tip.innerHTML = `
        <span class="chip"><span class="dot" style="background:${hit.color}"></span>${hit.key}</span>
        <div class="grid">
          <div class="k">Devengado Acumulado</div><div class="v">${fmtCompact(d.x)}</div>
          <div class="k">Monto de inversión</div><div class="v">${fmtCompact(d.y)}</div>
          <div class="k">Beneficiarios</div><div class="v">${(d.bens||0).toLocaleString('es-PE')}</div>
          <div class="k">% Avance</div><div class="v">${fmtPct(d.pct)}</div>
          ${d.icod ? `<div class="k">CUI</div><div class="v">${d.icod}</div>` : ''}
          ${d.nombre ? `<div class="hr"></div><div class="long">${d.nombre}</div>` : ''}
        </div>`;
      tip.style.display='block'; tip.style.opacity='0';
      positionTooltip(tip, mouseX, mouseY);
      tip.style.opacity='1';
    }

    canvas.addEventListener('mousemove', (e)=>{
      const rect = canvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const hit = hitTest(mx,my);
      canvas.style.cursor = hit ? 'pointer' : (inPlot(mx,my) ? 'crosshair' : 'default');
      if(hit){ showTooltip(hit, mx, my); }
      else { tip.style.opacity='0'; tip.style.display='none'; }
    });
    canvas.addEventListener('mouseleave', ()=>{
      tip.style.opacity='0'; tip.style.display='none';
    });
  }

  // Init
  draw();
  window.addEventListener('resize', draw, { passive:true });
  setupInteractions();
}

/* Run */
(async function(){
  try{
    const pts = await loadData();
    makeChart(pts);
  }catch(err){
    console.error(err);
    const el = document.getElementById("empty");
    el.style.display = "grid";
    el.textContent = "Error al cargar datos: " + (err.message || err);
  }
})();
</script>
</body>
</html>

