<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Devengado Acumulado VS Monto de Inversión</title>
<style>
  :root{ --ink:#0b2532; --muted:#64748b; --grid:#e5e7eb; }
  html,body{height:100%;margin:0;background:#fff;color:var(--ink);
    font-family:system-ui,Segoe UI,Roboto,Arial}
  .stage{height:100vh;width:100vw;display:grid;grid-template-rows:auto auto 1fr;
    gap:10px;padding:clamp(8px,2vw,20px); box-sizing:border-box}
  h1{margin:0;text-align:center;font-weight:900;letter-spacing:.3px;
     font-size:clamp(20px,3vw,42px)}
  .legendBar{display:flex;justify-content:center;align-items:center;gap:14px;flex-wrap:wrap;min-height:28px}
  .leg-btn{display:inline-flex;align-items:center;gap:8px;padding:6px 12px;border:1px solid #e5e7eb;border-radius:999px;cursor:pointer;background:#fff;font-weight:700;font-size:13px}
  .leg-btn[aria-pressed="false"]{opacity:.35;background:#f8fafc}
  .sw{width:12px;height:12px;border-radius:50%}
  .chartWrap{position:relative;overflow:hidden;border-radius:14px}
  canvas{display:block;width:100%;height:100%}
  .empty{display:grid;place-items:center;height:100%;color:#64748b;font-size:clamp(13px,1.6vw,16px);padding:12px;text-align:center}

  /* ===== Tooltip (compacto) ===== */
  .tip{
    position:absolute; pointer-events:none; color:#0b2532;
    background:#ffffff; border:1px solid #e5e7eb;
    box-shadow:0 10px 24px rgba(2,6,23,.12), 0 2px 6px rgba(2,6,23,.08);
    border-radius:10px; padding:8px 10px; font-size:11px; line-height:1.25;
    opacity:0; transform:translate(-50%,-110%); transition:opacity .12s ease;
    max-width:min(360px,68vw)
  }
  .tip .chip{
    display:inline-flex; align-items:center; gap:6px;
    font-weight:800; padding:3px 8px; border-radius:999px;
    background:#f8fafc; border:1px solid #e5e7eb; font-size:10.5px;
    letter-spacing:.02em;
  }
  .tip .dot{width:9px;height:9px;border-radius:50%;display:inline-block}
  .tip .grid{
    margin-top:6px; display:grid; grid-template-columns:auto 1fr; gap:4px 10px;
  }
  .tip .k{color:#64748b}
  .tip .v{font-weight:700; text-align:right}
  .tip .hr{margin:6px 0; height:1px; background:#eef2f7; grid-column:1/-1}
  .tip .long{grid-column:1/-1; text-align:left; font-weight:600}
</style>
</head>
<body>
  <div class="stage">
    <h1>Devengado Acumulado VS Monto de Inversión</h1>

    <!-- Leyenda interactiva centrada -->
    <div class="legendBar" id="legendBar" role="toolbar" aria-label="Filtrar por Nivel de Avance"></div>

    <div class="chartWrap" id="wrap" aria-live="polite">
      <canvas id="chart"></canvas>
      <div id="empty" class="empty" style="display:none">Sin datos que cumplan los filtros.</div>
      <div id="tip" class="tip" role="status"></div>
    </div>
  </div>

<script>
/* -------- Endpoints -------- */
const LYR13 = "https://pportalgis.vivienda.gob.pe/pfdserver/rest/services/OGEI/Mapa_Inversiones_MEF/FeatureServer/13/query";
const LYR1  = "https://pportalgis.vivienda.gob.pe/phtserver/rest/services/Hosted/story_monitoreo_inversiones/FeatureServer/1/query";

/* -------- Filtros CAPA 13 (válidos) -------- */
const WHERE_13 = "monto_pim > 0 AND producto_proyecto IS NOT NULL AND producto_proyecto <> 2193247";

/* -------- Filtros CAPA 1 (datos del scatter) -------- */
const WHERE_1 = "etapa IN ('OBRA','OBRA (SALDO)') AND montoactualizadopip_decimal > 0 AND devengadoacumulado >= 0";

/* -------- Categorías por % -------- */
const CATS = [
  {key:"Bajo (0%–30%)",   short:"Bajo",  color:"#dc2626", match:p=> p<=30},
  {key:"Medio (30%–70%)", short:"Medio", color:"#f59e0b", match:p=> p>30 && p<70},
  {key:"Alto (70%–100%)", short:"Alto",  color:"#22c55e", match:p=> p>=70}, // incluye >100
];

/* -------- Utils -------- */
function pct(dev, inv){
  const d=Number(dev), m=Number(inv);
  if(!isFinite(d)||!isFinite(m)||m<=0) return 0;
  return (d/m)*100;
}
function catFromPct(p){ for(const c of CATS){ if(c.match(p)) return c.short; } return "Bajo"; }
function fmtCompact(n){
  const v=Number(n)||0, a=Math.abs(v);
  if(a>=1e9) return (v/1e9).toFixed(1).replace(/\.0$/,'')+" B";
  if(a>=1e6) return (v/1e6).toFixed(1).replace(/\.0$/,'')+" M";
  if(a>=1e3) return (v/1e3).toFixed(1).replace(/\.0$/,'')+" k";
  return v.toLocaleString('es-PE');
}
function fmtPct(p){ return (Math.round(p*10)/10).toLocaleString('es-PE')+"%"; }

/* ArcGIS helpers (POST + paginado) */
async function fetchAllPOST(url, baseParams){
  const pageSize=2000; let offset=0, out=[];
  while(true){
    const body = new URLSearchParams({
      ...baseParams, returnGeometry:"false", f:"json",
      resultRecordCount: pageSize, resultOffset: offset
    }).toString();
    const res = await fetch(url, {
      method:"POST",
      headers:{ "Content-Type":"application/x-www-form-urlencoded;charset=UTF-8" },
      body, cache:"no-store"
    });
    if(!res.ok) throw new Error("HTTP "+res.status);
    const j = await res.json();
    if(j.error) throw new Error("ArcGIS: "+(j.error.message||"consulta inválida"));
    const feats = j.features ?? [];
    out.push(...feats.map(f=>f.attributes||{}));
    if(!j.exceededTransferLimit && feats.length<pageSize) break;
    offset += pageSize;
  }
  return out;
}

/* -------- Carga de datos -------- */
async function loadData(){
  // 1) IDs válidos desde CAPA 13
  const rows13 = await fetchAllPOST(LYR13, { where: WHERE_13, outFields: "producto_proyecto" });
  const idSet = new Set(rows13.map(r=>r.producto_proyecto).filter(v=>v!=null));
  if(idSet.size===0) return [];

  // 2) Traemos de CAPA 1 con IN (…) en chunks
  const ids = Array.from(idSet);
  const chunkSize = 900;
  let rows1 = [];
  for(let i=0;i<ids.length;i+=chunkSize){
    const slice = ids.slice(i,i+chunkSize);
    const where = `${WHERE_1} AND icodunificado IN (${slice.join(",")})`;
    const part = await fetchAllPOST(LYR1, {
      where,
      outFields: "icodunificado,devengadoacumulado,montoactualizadopip_decimal,nombreproyecto,beneficiarios"
    });
    rows1.push(...part);
  }

  // 3) Transformamos
  const pts = rows1.map(r=>{
    const x = Number(r.devengadoacumulado)||0;
    const y = Number(r.montoactualizadopip_decimal)||0;
    const bens = Number(r.beneficiarios)||0;
    const p = pct(x,y);
    return {
      x, y, bens, pct: p, nivel: catFromPct(p),
      icod: r.icodunificado ?? "",
      nombre: (r.nombreproyecto ?? "").toString().trim()
    };
  }).filter(d=>d.y>0);

  return pts;
}

/* -------- Gráfico (Canvas) + ZOOM / PAN -------- */
function makeChart(points){
  const wrap   = document.getElementById("wrap");
  const canvas = document.getElementById("chart");
  const ctx    = canvas.getContext("2d");
  const empty  = document.getElementById("empty");
  const tip    = document.getElementById("tip");
  const legend = document.getElementById("legendBar");

  if(!points.length){ empty.style.display="grid"; return; }
  empty.style.display="none";

  // Leyenda interactiva (igual)
  const visible = new Map(CATS.map(c=>[c.short,true]));
  legend.innerHTML="";
  CATS.forEach(c=>{
    const b=document.createElement("button");
    b.className="leg-btn"; b.type="button"; b.setAttribute("aria-pressed","true");
    b.innerHTML=`<span class="sw" style="background:${c.color}"></span>${c.key}`;
    b.onclick=()=>{ const cur=visible.get(c.short); visible.set(c.short,!cur); b.setAttribute("aria-pressed",String(!cur)); draw(); };
    legend.appendChild(b);
  });

  // Tamaño por beneficiarios
  const maxB = Math.max(1, ...points.map(p=>p.bens||0));
  const minR = 4, maxR = 22;
  const rScale = (b)=> {
    const t = Math.sqrt((b||0)/maxB);
    return minR + t * (maxR - minR);
  };

  // ===== Estado de la vista para zoom/pan =====
  let dims={}, scale={};
  // Extremos de datos (se recalculan con la leyenda)
  let dataMaxX=1, dataMaxY=1;
  // Ventana visible en coordenadas de datos
  let view = {minX:0, maxX:1, minY:0, maxY:1};

  function computeDataExtents(){
    const act=points.filter(p=>visible.get(p.nivel));
    dataMaxX = Math.max(1, ...act.map(p=>p.x));
    dataMaxY = Math.max(1, ...act.map(p=>p.y));
    if(view.maxX===1 && view.maxY===1){
      view.minX=0; view.maxX=dataMaxX; view.minY=0; view.maxY=dataMaxY;
    }else{
      // si la leyenda ocultó la mayoría, asegura que la ventana no sea mayor que el nuevo dominio
      view.minX = Math.max(0, Math.min(view.minX, dataMaxX*0.99));
      view.maxX = Math.min(dataMaxX, Math.max(view.maxX, view.minX+1));
      view.minY = Math.max(0, Math.min(view.minY, dataMaxY*0.99));
      view.maxY = Math.min(dataMaxY, Math.max(view.maxY, view.minY+1));
    }
  }

  function compute(){
    const dpr=Math.max(1,window.devicePixelRatio||1);
    const W=wrap.clientWidth,H=wrap.clientHeight;
    canvas.width=W*dpr; canvas.height=H*dpr; canvas.style.width=W+"px"; canvas.style.height=H+"px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
    dims={W,H};
    const pad={t:40,r:24,b:64,l:86};
    scale={pad,
      x:v=>pad.l+(W-pad.l-pad.r)*((v-view.minX)/((view.maxX-view.minX)||1)),
      y:v=>pad.t+(H-pad.t-pad.b)*(1-(v-view.minY)/((view.maxY-view.minY)||1))
    };
  }

  function drawAxes(){
    const {pad}=scale; const W=dims.W,H=dims.H;
    ctx.clearRect(0,0,W,H);

    // Y
    ctx.textAlign="right"; ctx.textBaseline="middle"; ctx.font="12px system-ui"; ctx.fillStyle="#0b2532";
    const yTicks=5;
    for(let i=0;i<=yTicks;i++){
      const v=view.minY+(view.maxY-view.minY)*i/yTicks, yy=scale.y(v);
      ctx.strokeStyle=i===0?"#e5e7eb":"#f3f4f6";
      ctx.beginPath(); ctx.moveTo(scale.pad.l,yy); ctx.lineTo(W-scale.pad.r,yy); ctx.stroke();
      ctx.fillText(fmtCompact(v), scale.pad.l-8, yy);
    }

    // X
    const xTicks=5;
    ctx.textAlign="center"; ctx.textBaseline="top"; ctx.font="12px system-ui";
    for(let i=0;i<=xTicks;i++){
      const v=view.minX+(view.maxX-view.minX)*i/xTicks;
      const xx=scale.x(v); const y0=H-scale.pad.b;
      ctx.strokeStyle="#e5e7eb";
      ctx.beginPath(); ctx.moveTo(xx,scale.pad.t); ctx.lineTo(xx,y0); ctx.stroke();
      ctx.fillText(fmtCompact(v), xx, y0+10);
    }

    // etiquetas ejes
    ctx.save(); ctx.fillStyle="#0b2532"; ctx.font="600 13px system-ui";
    ctx.translate(28,H/2); ctx.rotate(-Math.PI/2); ctx.fillText("Monto de Inversión",0,0); ctx.restore();
    ctx.textAlign="center"; ctx.textBaseline="bottom";
    ctx.fillText("Devengado Acumulado", scale.pad.l+(W-scale.pad.l-scale.pad.r)/2, H-6);
  }

  // Puntos + hit map
  let HIT=[];
  function drawPoints(){
    HIT=[];
    CATS.forEach(c=>{
      if(!visible.get(c.short)) return;
      ctx.fillStyle=c.color;
      points.forEach(p=>{
        if(p.nivel!==c.short) return;
        const x=scale.x(p.x), y=scale.y(p.y), r=rScale(p.bens);
        if(isFinite(x)&&isFinite(y)){
          ctx.beginPath(); ctx.arc(x,y,r,0,2*Math.PI); ctx.fill();
          HIT.push({x,y,r:Math.max(r+2,8),data:p,color:c.color, key:c.key});
        }
      });
    });
  }

  function draw(){ computeDataExtents(); compute(); drawAxes(); drawPoints(); }
  draw(); window.addEventListener("resize",draw,{passive:true});

  // ===== Tooltip
  function hitAtClient(clientX, clientY){
    const rect = canvas.getBoundingClientRect();
    const mx = clientX - rect.left;
    const my = clientY - rect.top;
    let best=null, bestD=Infinity;
    for(let i=HIT.length-1;i>=0;i--){
      const h=HIT[i], dx=mx-h.x, dy=my-h.y, d2=dx*dx+dy*dy;
      if(d2 <= h.r*h.r && d2 < bestD){ best=h; bestD=d2; }
    }
    return {hit:best, mx, my};
  }
  function showTip(h,mx,my){
    const d=h.data;
    const html =
      `<span class="chip"><span class="dot" style="background:${h.color}"></span>${h.key}</span>`+
      `<div class="grid">`+
        `<div class="k">Devengado Acumulado</div><div class="v">${fmtCompact(d.x)}</div>`+
        `<div class="k">Monto de inversión</div><div class="v">${fmtCompact(d.y)}</div>`+
        `<div class="k">Beneficiarios</div><div class="v">${(d.bens||0).toLocaleString('es-PE')}</div>`+
        `<div class="k">% Avance</div><div class="v">${fmtPct(d.pct)}</div>`+
        (d.icod ? `<div class="k">CUI</div><div class="v">${d.icod}</div>` : ``)+
        (d.nombre ? `<div class="hr"></div><div class="long">${d.nombre}</div>` : ``)+
      `</div>`;
    tip.innerHTML = html;
    const rect=wrap.getBoundingClientRect();
    let x=mx+12, y=my-14;
    x=Math.min(rect.width-10,Math.max(10,x));
    y=Math.min(rect.height-10,Math.max(10,y));
    tip.style.left = x+"px"; tip.style.top = y+"px"; tip.style.opacity = 1;
  }
  function hideTip(){ tip.style.opacity=0; }
  canvas.addEventListener("mousemove",(e)=>{
    const {hit, mx, my} = hitAtClient(e.clientX, e.clientY);
    canvas.style.cursor = hit ? "pointer" : "default";
    if(hit) showTip(hit, mx, my); else hideTip();
  },{passive:true});
  canvas.addEventListener("mouseleave", hideTip, {passive:true});

  // ====== Interacción: ZOOM & PAN ======
  function pxToData(mx,my){
    const W=dims.W,H=dims.H,p=scale.pad;
    const xRatio = (mx - p.l) / (W - p.l - p.r);
    const yRatio = 1 - (my - p.t) / (H - p.t - p.b);
    return {
      x: view.minX + (view.maxX - view.minX) * Math.min(1,Math.max(0,xRatio)),
      y: view.minY + (view.maxY - view.minY) * Math.min(1,Math.max(0,yRatio))
    };
  }
  function clampView(){
    view.minX = Math.max(0, view.minX);
    view.minY = Math.max(0, view.minY);
    view.maxX = Math.min(dataMaxX, view.maxX);
    view.maxY = Math.min(dataMaxY, view.maxY);
    const minSpanX = dataMaxX/1e6 || 1;
    const minSpanY = dataMaxY/1e6 || 1;
    if((view.maxX-view.minX) < minSpanX) view.maxX = view.minX + minSpanX;
    if((view.maxY-view.minY) < minSpanY) view.maxY = view.minY + minSpanY;
  }

  // Zoom con rueda (sobre el cursor)
  canvas.addEventListener("wheel",(e)=>{
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left, my = e.clientY - rect.top;
    const c = pxToData(mx,my);
    const factor = e.deltaY > 0 ? 1.15 : 1/1.15;
    view.minX = c.x + (view.minX - c.x) * factor;
    view.maxX = c.x + (view.maxX - c.x) * factor;
    view.minY = c.y + (view.minY - c.y) * factor;
    view.maxY = c.y + (view.maxY - c.y) * factor;
    clampView();
    draw();
  },{passive:false});

  // Pan (arrastrar)
  let dragging=false, last=null;
  canvas.addEventListener("mousedown",(e)=>{ dragging=true; last={x:e.clientX,y:e.clientY}; tip.style.opacity=0; });
  window.addEventListener("mouseup",()=> dragging=false);
  window.addEventListener("mousemove",(e)=>{
    if(!dragging) return;
    const dx=e.clientX-last.x, dy=e.clientY-last.y; last={x:e.clientX,y:e.clientY};
    const spanX=view.maxX-view.minX, spanY=view.maxY-view.minY;
    const rx = dx / (dims.W - scale.pad.l - scale.pad.r);
    const ry = dy / (dims.H - scale.pad.t - scale.pad.b);
    view.minX -= rx*spanX; view.maxX -= rx*spanX;
    view.minY += ry*spanY; view.maxY += ry*spanY; // Y invertida
    clampView();
    draw();
  });

  // Doble-clic = reset
  canvas.addEventListener("dblclick", ()=>{
    view.minX=0; view.maxX=dataMaxX; view.minY=0; view.maxY=dataMaxY;
    draw();
  });
}

/* -------- Run -------- */
(async function(){
  try{
    const pts = await loadData();
    makeChart(pts);
  }catch(err){
    console.error(err);
    const el=document.getElementById("empty"); el.style.display="grid";
    el.textContent="Error al cargar datos: "+(err.message||err);
  }
})();
</script>
</body>
</html>
