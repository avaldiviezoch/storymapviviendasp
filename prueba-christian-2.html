<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Bubble chart dinámico — Gasto vs Acceso Agua (ENAPRES como tamaño)</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
  <style>
    html,body{height:100%;margin:0;background:#fff;font-family:system-ui,Arial}
    #chart{height:100vh;width:100vw}
  </style>
</head>
<body>
<div id="chart"></div>

<script>
/* ==========================================================
   CONFIG — mapea qué layer corresponde a cada métrica
   ========================================================== */
/*
  Según tu descripción:
  - X: gasto (ogei.tb_pob_ejecucion_total_1)
  - Y: población con acceso a agua (tb_pob_acceso_1)
  - SIZE: población en miles (ogei.tb_pob_enapres_1)

  He asignado (por los campos que mostraste):
   * LYR_X   = 5  (dobles + col_ab)  -> ejecucion total (gasto)
   * LYR_Y   = 3  (anio integer + dobles) -> acceso a agua
   * LYR_SIZE= 4  (anio string + mixto)   -> ENAPRES (pob. miles)

  Si tu mapeo fuese distinto, SOLO cambia estos 3 IDs.
*/
const SERVICE_BASE = "https://pportalgis.vivienda.gob.pe/phtserver/rest/services/Hosted/Mapa_coropletico_2/FeatureServer";
const LYR_X    = 5; // eje X   (gasto S/)
const LYR_Y    = 3; // eje Y   (población con acceso a agua)
const LYR_SIZE = 4; // tamaño  (población ENAPRES, en miles)

const YEAR_START = 2011;
const YEAR_END   = 2024;

/* ==========================================================
   Claves de región (columnas) y nombres bonitos
   (deben coincidir EXACTO con los nombres de campo en la tabla)
   ========================================================== */
const REGION_COLS = [
  { key:'amazonas', display:'Amazonas' },
  { key:'ancash', display:'Áncash' },
  { key:'apurimac', display:'Apurímac' },
  { key:'arequipa', display:'Arequipa' },
  { key:'ayacucho', display:'Ayacucho' },
  { key:'cajamarca', display:'Cajamarca' },
  { key:'provincia_constitucional_del_ca', display:'Callao' }, // alias largo en tabla
  { key:'cusco', display:'Cusco' },
  { key:'huancavelica', display:'Huancavelica' },
  { key:'huanuco', display:'Huánuco' },
  { key:'ica', display:'Ica' },
  { key:'junin', display:'Junín' },
  { key:'la_libertad', display:'La Libertad' },
  { key:'lambayeque', display:'Lambayeque' },
  { key:'lima', display:'Lima' },
  { key:'loreto', display:'Loreto' },
  { key:'madre_de_dios', display:'Madre de Dios' },
  { key:'moquegua', display:'Moquegua' },
  { key:'pasco', display:'Pasco' },
  { key:'piura', display:'Piura' },
  { key:'puno', display:'Puno' },
  { key:'san_martin', display:'San Martín' },
  { key:'tacna', display:'Tacna' },
  { key:'tumbes', display:'Tumbes' },
  { key:'ucayali', display:'Ucayali' }
];

/* ==========================================================
   Helpers
   ========================================================== */
const chart = echarts.init(document.getElementById('chart'));

function qs(url, params) {
  return url + "?" + new URLSearchParams(params).toString();
}
async function fetchTable(layerId) {
  // Trae todas las columnas (para no pifiarla con tipos) y sin geometría
  const url = qs(`${SERVICE_BASE}/${layerId}/query`, {
    where: "1=1",
    outFields: "*",
    returnGeometry: "false",
    orderByFields: "anio ASC",
    f: "json"
  });
  const res = await fetch(url, { cache: 'no-store' });
  if (!res.ok) throw new Error(`HTTP ${res.status} al consultar layer ${layerId}`);
  const json = await res.json();
  if (json.error) throw new Error(json.error.message || `Error del servicio en layer ${layerId}`);
  const feats = json.features || [];
  // Normalizamos {year:number -> attributes}
  const byYear = new Map();
  for (const f of feats) {
    const a = (f.attributes || {});
    // anio puede ser string o int según layer, lo pasamos a number
    const yrRaw = a.anio;
    const yr = typeof yrRaw === 'string' ? parseInt(yrRaw, 10) : Number(yrRaw);
    if (Number.isFinite(yr)) byYear.set(yr, a);
  }
  return byYear;
}

// Devuelve [min,max] no NaN de una lista
function extent(arr) {
  let min = +Infinity, max = -Infinity;
  for (const v of arr) {
    if (Number.isFinite(v)) { if (v < min) min = v; if (v > max) max = v; }
  }
  if (!Number.isFinite(min) || !Number.isFinite(max)) return [0,1];
  if (min === max) return [0, max || 1];
  return [min, max];
}

// size scaling ~ similar a ejemplo (pero con datos reales)
function makeSizeFn(values) {
  const [mn, mx] = extent(values);
  // Evitar 0; usar sqrt para comprimir rangos grandes
  return function sizeFn(x) {
    const v = Math.max(0, Number(x)||0);
    const t = mx > 0 ? (v / mx) : 0;
    return (Math.sqrt(t) + 0.10) * 60; // ajusta factor a gusto
  };
}

/* ==========================================================
   Main
   ========================================================== */
(async function run(){
  try {
    chart.showLoading({ text: 'Cargando datos…' });

    // 1) Traer las 3 tablas
    const [xByYear, yByYear, sByYear] = await Promise.all([
      fetchTable(LYR_X),
      fetchTable(LYR_Y),
      fetchTable(LYR_SIZE)
    ]);

    // 2) Armar timeline + series por año
    const years = [];
    for (let y = YEAR_START; y <= YEAR_END; y++) years.push(y);

    // Precalcular todos los tamaños para escalar correctamente
    const allSizes = [];
    years.forEach(y => {
      const rowS = sByYear.get(y) || {};
      for (const {key} of REGION_COLS) {
        const valS = Number(rowS[key]);
        if (Number.isFinite(valS)) allSizes.push(valS);
      }
    });
    const sizeFn = makeSizeFn(allSizes);

    // Construir options por año
    const options = [];
    for (const y of years) {
      const rowX = xByYear.get(y) || {};
      const rowY = yByYear.get(y) || {};
      const rowS = sByYear.get(y) || {};

      const points = REGION_COLS.map(({key, display}) => {
        const xVal = Number(rowX[key]);     // gasto S/.
        const yVal = Number(rowY[key]);     // acceso agua
        const sVal = Number(rowS[key]);     // población miles
        return [xVal, yVal, sVal, display];
      }).filter(d => Number.isFinite(d[0]) && Number.isFinite(d[1]));

      options.push({
        title: { show: true, text: String(y) },
        series: [{
          name: String(y),
          type: 'scatter',
          data: points,
          itemStyle: { opacity: 0.85 },
          symbolSize: function (val) { return sizeFn(val[2]); }
        }]
      });
    }

    // 3) Colorear por región (categorías)
    const categories = REGION_COLS.map(r => r.display);
    const colorPalette = ['#51689b','#ce5c5c','#fbc357','#8fbf8f','#659d84','#fb8e6a','#c77288','#786090','#91c4c5','#6890ba'];
    const regionColors = [];
    while (regionColors.length < categories.length) {
      regionColors.push(...colorPalette);
    }

    // 4) BaseOption (timeline vertical autoplay)
    const option = {
      baseOption: {
        timeline: {
          axisType: 'category',
          orient: 'vertical',
          autoPlay: true,
          inverse: true,
          playInterval: 1200,
          right: 0,
          top: 20,
          bottom: 20,
          width: 55,
          symbol: 'none',
          checkpointStyle: { borderWidth: 2 },
          controlStyle: { showNextBtn: false, showPrevBtn: false },
          data: years
        },
        title: [
          {
            text: years[0],
            textAlign: 'center',
            left: '63%',
            top: '55%',
            textStyle: { fontSize: 80, fontWeight: 600, color: '#e5e7eb' }
          },
          {
            text: 'Gasto (S/) vs Población con acceso a agua — tamaño: Población (miles)',
            left: 'center',
            top: 8,
            textStyle: { fontWeight: '600', fontSize: 16 }
          }
        ],
        tooltip: {
          padding: 6,
          borderWidth: 1,
          formatter: function (obj) {
            const v = obj.value;
            return (
              `<b>${v[3]}</b><br>` +
              `Acceso a agua: <b>${Number(v[1]).toLocaleString('es-PE')}</b><br>` +
              `Gasto (S/): <b>${Number(v[0]).toLocaleString('es-PE')}</b><br>` +
              `Población (miles): <b>${Number(v[2]).toLocaleString('es-PE')}</b>`
            );
          }
        },
        grid: { top: 80, left: 40, right: 110, bottom: 40, containLabel: true },
        xAxis: {
          type: 'log',
          name: 'Gasto (S/)',
          min: 300, max: 100000000, // ajusta si lo necesitas; el log se adapta
          nameGap: 25,
          nameLocation: 'middle',
          nameTextStyle: { fontSize: 14 },
          splitLine: { show: false },
          axisLabel: { formatter: (v) => new Intl.NumberFormat('es-PE').format(v) }
        },
        yAxis: {
          type: 'value',
          name: 'Población con acceso al agua',
          nameTextStyle: { fontSize: 14 },
          splitLine: { show: true },
          axisLabel: { formatter: (v) => new Intl.NumberFormat('es-PE').format(v) }
        },
        visualMap: [{
          show: false,
          dimension: 3,
          categories: categories,
          inRange: {
            color: regionColors
          }
        }],
        series: [{
          type: 'scatter',
          data: [], // se reemplaza por cada year en options
          symbolSize: function (val) { return sizeFn(val[2]); }
        }],
        animationDurationUpdate: 1000,
        animationEasingUpdate: 'quinticInOut'
      },
      options
    };

    chart.hideLoading();
    chart.setOption(option);

    // Ajuste responsivo
    window.addEventListener('resize', () => chart.resize());

  } catch (err) {
    console.error(err);
    chart.hideLoading();
    chart.setOption({
      title: { text:'Error al cargar datos', left:'center' },
      graphic: {
        type:'text', left:'center', top:'middle',
        style:{ text: (err && err.message) ? err.message : 'Fallo de carga.\nRevisa URL, permisos (token) o campos.', fontSize: 14 }
      }
    });
  }
})();
</script>
</body>
</html>
